\documentclass[a4paper, 11pt]{article}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}%Veröffentlichungssprache
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage[format=plain,justification=RaggedRight,singlelinecheck=false,font={small},labelsep=space]{caption}
\usepackage[dvipsnames]{xcolor}	
\usepackage[a4paper]{geometry}
	\geometry{left=3.5cm,right=2.5cm,top=2.4cm,bottom=2cm}%Seitenränder
	\usepackage[onehalfspacing]{setspace}%Zeilenabstand
	\renewcommand{\\}{\vspace*{0.5\baselineskip} \newline}
\renewcommand*\MakeUppercase[1]{#1}	
\usepackage{tablefootnote}
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0pt}
	\fancyhead[R]{\footnotesize{\thepage}}
	\fancyhead[L]{\footnotesize{\leftmark}}
	\fancyfoot{}
\usepackage[colorlinks,
pdfpagelabels,
pdfstartview = FitH,
bookmarksopen = true,
bookmarksnumbered = true,
linkcolor = black,
urlcolor = black,
plainpages = false,
hypertexnames = false,
citecolor = black] {hyperref}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage[
	backend=biber,
	style=apa
]{biblatex}
\addbibresource{refs.bib}

\renewcommand{\familydefault}{\sfdefault}

\begin{document}

\title{How do various plagiarism detection tools differ in their detection results when applied to java/spring coding exercises}
\author{Dennis Goßler \and Dennis Wäckerle}
\maketitle

\section*{Abstract}
\newpage
\tableofcontents
\newpage

\section{Introduction}

\section{How Does Plagiarism Detection Work}


*Fand den Abschnitt bei moss ganz nett könnte man ja mit reinpacken* Dennis G.

Moss and other plagiarism detection tools are not perfect, so a human should go other the results, and it should be checked if the clams are valid.
"In particular, it is a misuse of Moss to rely solely on the similarity scores. These scores are useful for judging the relative amount of matching between different pairs of programs and for more easily seeing which pairs of programs stick out with unusual amounts of matching. But the scores are certainly not a proof of plagiarism. Someone must still look at the code."
\autocite{SMOSS}

\section{Use Case and Software Experiment}

\subsection{Use Case}

\subsection{Software Experiment}

\section{Criteria for Evaluation}

\section{Evaluation of the different Tools}


\begin{table}[h]
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
	\hline
			& C   & C++ & C\# & Java & Kotlin & Python & PHP & VB.net & Javascript & Is expandable? \\ \hline
	MOSS    & Yes & Yes & Yes & Yes  & No     & Yes    & No  & Yes    & Yes        & No             \\ \hline
	JPlag   & No  & Yes & Yes & Yes  & Yes    & Yes    & No  & No     & No         & Yes            \\ \hline
	Plaggie & No  & No  & No  & Yes  & No     & No     & No  & No     & No         & Yes\tablefootnote{Plaggie is open source, therefore a custom tokenizer for different languages can be implemented.}            \\ \hline
	AC2     & Yes & Yes & No  & Yes  & No     & Yes    & Yes & No     & No         & Yes             \\ \hline
	\end{tabular}
	\caption{\label{tab:table-name}[The native supported programming languages for each plagiarism detection algorithm]}
\end{table}




\subsection{MOSS}

Moss clams to be one of the best cheating detection algorithms.
"The algorithm behind moss is a significant improvement over other cheating detection algorithms (at least, over those known to us)."
\autocite{SMOSS}

Moss supports the following programming languages C, C++, Java, C\#, Python, Visual Basic, Javascript, FORTRAN, ML, Haskell, Lisp, Scheme, Pascal, Modula2, Ada, Perl, TCL, Matlab, VHDL, Verilog, Spice, MIPS assembly, a8086 assembly, a8086 assembly and HCL2

\subsection{JPlag}

JPlag is a plagiarism detection tool, which was developed by in 2000 at the University of Karlsruhe to help with the detection of plagiarized coding
exercises. At that the tool was only available as a WWW service and could analyze C, C++. Scheme and Java programs \autocite[p. 4]{JPlagP}. Currently, the tool is available
as an open source application which can be run locally and can be used with a CLI or a Java API. JPlag also currently supports 12 programming languages
including the original four languages and more modern languages such as Kotlin \autocite[Supported Languages
]{JPlagG} while also allowing to add new languages \autocite{JPlagW4}.

\subsubsection{JPlag's comparison algorithm}

JPlag's algorithm is split into two parts the tokenizing and the comparison of the token strings. During the tokenization
process all programs are parsed and converted into token strings. In the second phase all token strings are compared
in pairs to determine their similarity. This comparison uses a specially optimized version of the Greedy String Tiling
algorithm. This algorithm tries to cover one token string with substrings of the other string. The percentage of the covered token 
strings is the similarity between the two programs \autocite[p. 10]{JPlagP}.

\paragraph{Tokenization}

The tokenization process is the only language dependent process of the JPlag algorithm \autocite[p. 10]{JPlagP}. The extracted tokens
represent syntactic elements of the language like statements or control structures \autocite[How are submissions represented? — Notion of Token]{JPlagW4}.
During the parsing process each file is parsed with the result being a set of abstract syntax trees(AST) for each submission. Each AST
is traversed depth first with nodes representing grammatical units of the language. During the traversal when entering and exiting a 
node a token can be created that match the type of the node and will then be added to the current list of tokens. There are block type
nodes which can represent classes, if expressions or other elements of the language which have a corresponding beginning and end. When
creating tokens from those nodes each have a corresponding "BEGIN" and "END" token. The token list should always have a pair of matching
"BEGIN" and "END" tokens \autocite[How does the transformation work?]{JPlagW4}.

\paragraph{Comparing token strings}

JPlag's comparison algorithm is essentially just the greedy string tiling algorithm for the comparison of two strings, however it is differently
optimized to improve its runtime\autocite[p. 5]{JPlagP}. The goal of the algorithm is to find a set of substrings
which are not only the same but also satisfy these three rules:

\begin{enumerate}
	\item "Any token of A may only be matched with exactly one token from B."
	\item "Substrings are to be found independent of their position in the string."
	\item "Long substring matches are preferred over short ones[...]"
\end{enumerate}\autocite[p. 11]{JPlagP}

These rule have some consequences. The first rule doesn't allow the matching of code that have been duplicated while
the second rule makes the reordering of the source code not viable. Furthermore, the third rule is introduced since
short matches are more likely to be spurious \autocite[p. 11]{JPlagP}.


- Applying the third rule sequentially leads to a greedy algorithm consisting of two phases
1. Two strings are searched for the biggest contigous matches. 3 nested Loops. Outer loop iterates over tokens in
	string A. Second loop compares Token T to Tokens in String B. Inner loop, if identical Tokens, extends the match
	as far as possible. Collects Set of longest common substrings
2. Marks all matches of maximal length. All tokens are marked and can not be used for further matches. Satisfies rule 1
- Repeat until no further matches found \autocite[p. 11]{JPlagP}
- tile is a unique and permanent association of a substring from A with a matching substring from B\autocite[p. 3]{GST}
- MinimumMatchLength is defined must be atleast 1, should probably be higher, since it is unlikely that such a match
	will be significant \autocite[GST]{GST}

-similarity considers 100\% if the shorter string is completly covered \autocite[p. 13]{JPlagP}(See maths formula)

\subsubsection{The results}

-comparisons without base code
-successfully discovered plagiarism for m0 91.49\% and 90.51\% match
-Other comparisons around 40\%
-need base code

-m4 less clear 84.77\%-76.2\%
-need base code and another submission

\subsubsection{Integration into an automated evaluation pipeline}

-Can be executed locally
-Has a cli and an api -> allows automation
-Visualization in external web application -> might pose a problem

-known unsuccessful attacks
- Changing the comments
- Changing the indentation
- Method and variable name changes\autocite[Known successful attacks]{RMP}

-know successful attacks
- Moving inline code to separate methods and vice versa
- Inclusion of redundant program code
- Changing the order of if-else blocks and case-blocks\autocite[Known unsuccessful attacks]{RMP}

\subsection{Plaggie}

-Was the only open source tool when release\autocite{PLAGGIE}, JPlag now also open source

\subsubsection{The Algorithm}

-Uses CUP as a Parser
-Uses standard LALR(1) parser generation\autocite{CUP}
-GST with no special optimization attempts
-Algorithm was extended to support exclusion of common code\autocite[4. Algorithm used]{RMP}

\subsubsection{The results}

-TODO still have to run it.

\subsubsection{Integration into an automated evaluation pipeline}

-only Java 1.5\autocite{PLAGGIE,RMP}
-no further development since 2006
-has a cli -> can be automated
-results as html files

\subsection{AC2}

"AC was born in the Escuela Politécnica Superior of the Universidad Autónoma de Madrid to deter and detect source-code plagiarism in programming assignments." \autocite{AC2}


\subsubsection{AC2 comparison algorithm}

The output that AC2 generates is visualization base. So AC it will not provide a value like "percentage of copy" instead, "it will create graphical representations of the degree of similarity between student submissions within a group" \autocite{AC2}   


\subsubsection{The results}

\subsubsection{Integration into an automated evaluation pipeline}



\section{Conclusion}

\newpage

\printbibliography[
	heading=bibintoc,
	title={References}
]

\appendix

\end{document}